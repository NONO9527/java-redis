## 第一部分 数据结构与对象

### 简单动态字符串（SDS）

1. 常数复杂度获取字符串长度
2. 杜绝缓冲区溢出
3. 减少修改字符春长度时所需的内存重分配次数
4. 二进制安全
5. 兼容部分 C 字符串函数

### 链表（双端列表）

1. 双端
2. 无环，表头结点的 prev 指针和表位节点的 next 指针都指向 NULL，对链表的访问以  NULL 为终点。
3. 带表头和表尾指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）
4. 带链表长度计数器：程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数，程序获取链表中节点数量的复杂度为 O（1）。
5. 泛型：可以保存不同类型的节点

### 字典（Map）

1. 头插，java-HashMap 1.8 后是尾插
2. 拉练法解决哈希冲突
3. 双 table rehash
4. 渐进式rehash

### 跳表

- ConcurrentSkipListMap

### 整数集合

1. 集合
2. int long
3. 升级，不支持降级

## 对象

redisObject：

- 类型
- 编码（同一种对象的不同实现，需要有转换类），暂时只用单个实现，但是抽象出来，而且接口中设计出判断是否需要转换并执行的方法。
- 指向底层数据结构的指针
- 引用计数
- lru：该对象最后一i被命令程序访问的时间

字符串：sds，作为键，要有一些键空间的字段

- lru，与object的lru应该是独立的
- dirty

列表：双端列表

哈希：map

集合：set

有序集合：跳表

#### 命令多态

#### 证书字符串共享机制



## 第二部分 数据库

### 数据库

RedisServer：

- 一个db数组
- dbnum：数据库数量，默认为16
- saveparams；记录了保存条件的数组
  - seconds：秒数
  - changes：修改数
- dirty：修改计数器，距离上一次成功执行 save 或者 bgsave 命令后，服务器对数据库的状态（对所有数据库）进行了多少次修改（包括写入、删除、更新等操作）
- lastsave：时间戳，记录了服务器上一次成功执行 save 命令或者 bgsave 的时间
- aof _buf ：AOF 缓冲区

RedisClient：

- db：记录该客户端正在使用的数据库

RedisDb：

- dict：数据库键空间，保存这数据库中的所有键值对
- 键命中空间，未命中空间
- 过期字典：key指向键空间中的某个键对象，value为过期时间

**提供一个显示当前数据库的命令**

对数据库键空间的增删改查

读写键空间时的维护操作（额外操作）：

- 修改lru
- 过期时间判断
- 键命中/未命中
- dirty + 1

### 过期删除策略

惰性 + 定期 结合

惰性：像一个过滤器，每次操作键的时候都需要先判断

定期删除策略：每个数据库轮流进行检查，每轮记录进度

### RDB

创建

- save
  - 期间所有的 save 都会被拒绝
  - save 900 1 ： 服务器再900秒内，对服务器至少进行了一次修改
- bgsave 不能同时执行另外一个 bgsave
- bgsavewriteof  和 bgsave 不能同时执行

载入：每次服务器启动时候自动执行，载入期间一直处于阻塞状态，知道载入工作完成

- 优先使用AOF
- AOF处于关闭状态，才进行RDB

周期性操作函数 serverCron 默认每100 ms就会执行一次，检查 save 选项所设置的保存条件是否已经满足

#### RDB文件结构

大写：常量，全小写：变量和数据

![image-20220527193856702](image-20220527193856702-16536515467511.png)

- "REDSIS" ：通过这五个字符表示这是一个RDB 文件
- "db_version"：四字节，一个字符串表示的证书，记录了 RDB 文件的版本号
-  "database"：包含数据库的数据
- "check_sum"：校验和，对前四个字段计算得到

#### 分析 RDB 文件：redis-checj-dump

## AOF

创建一个伪客户端（不需要网络连接），执行还原操作

## 事件

### 文件事件

服务器对套接字操作的抽象：连接应答（accept）、读取（read）、写入（wrote）、关闭（close）

- 优先处理读事件

时间事件：定时任务

